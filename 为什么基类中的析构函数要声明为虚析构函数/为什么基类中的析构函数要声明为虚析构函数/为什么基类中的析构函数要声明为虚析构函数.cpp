// 为什么基类中的析构函数要声明为虚析构函数.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
/*
主要是，如果是派生类对象析构的话，那么派生类和基类都可以被析构
如果是动态绑定的，如基类的指针或引用指向派生类对象的话，那么这是只有基类的析构被调用了，派生类的不会被调用，造成内存泄露
*/

int _tmain(int argc, _TCHAR* argv[])
{
	return 0;
}

用对象指针来调用一个函数，有以下两种情况：

如果是虚函数，会调用派生类中的版本。

如果是非虚函数，会调用指针所指类型的实现版本。

析构函数也会遵循以上两种情况，因为析构函数也是函数嘛，不要把它看得太特殊。 当对象出了作用域或是我们删除对象指针，析构函数就会被调用。

当派生类对象出了作用域，派生类的析构函数会先调用，然后再调用它父类的析构函数， 这样能保证分配给对象的内存得到正确释放。

但是，如果我们删除一个指向派生类对象的基类指针，而基类析构函数又是非虚的话， 那么就会先调用基类的析构函数(上面第2种情况)，派生类的析构函数得不到调用。

请看例子：

